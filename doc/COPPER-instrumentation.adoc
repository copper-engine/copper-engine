= Copper Continuation by Instrumentation

:workflowDir: instrumentation/workflow
:bytecodeDir: instrumentation/bytecode
:decompiledDir: instrumentation/decompiled
:instrumentedDir: instrumentation/instrumented
:traceDir: instrumentation/trace

This documentation should help to understand the implementation of
https://en.wikipedia.org/wiki/Continuation[continuations] in the https://copper-engine.org/[COPPER Engine] Workflows.

COPPER Workflows can be interrupted and continued by using several methods:

* `savepoint`
* `wait`
* `waitForAll`.

In the following examples `savepoint` is used, but the concept is the same for the other methods.

Continuation is realized by using instrumentation with the https://asm.ow2.io/[ASM Framework].
Here we start with analyzing a <<OneSavepoint,first simple Workflow>> and a <<SavepointsAndSubWorkflows,second more complex Workflow>>.
Then we visit some <<Implementation,Implementation>> details.

[[OneSavepoint]]
== Example with one Savepoint

=== The original Workflow

This is the original Workflow with correct Java code.

[source%nowrap,java,linenums]
----
include::{workflowDir}/OneSavepoint.java[]
----

<1> `savepoint` in line 13.

When the main method it called the 1st time, the code up to the savepoint will be run.
Then the execution will be stopped until a 2nd call of the method will run the code up to its end.
How this is realized, the following chapters should explain.

=== The decompiled instrumented Workflow

This is the instrumented Workflow with incorrect Java code, generated by a decompiler.
Nevertheless, it helps to understand more of the COPPER internals.
In the following chapters we dive into the byte code, that holds the truth.

Keep in mind:

* The `main` method has no parameters.
* The `Workflow` has two imported COPPER internal members `\__stack` and `__stackPosition` using in the conditions.

[source%nowrap,java,linenums]
----
include::{decompiledDir}/OneSavepoint.java[]
----

<1> Condition is `true` for first call
<2> Storing `StackEntry` to `__stack` (no call stack parameters, jumpNo=0 and locals)
<3> Confusion and irrelevant increment of `__stackPosition`
<4> End of first call
<5> Condition is `true` for second call
<6> Get `locals` to restore local variables
<7> Assignment to `this` in line 26 is invalid
<8> Restore `i1`
<9> Restore `i2`
<10> Removing `StackEntry` from top of `__stack`

We see the original code embedded in conditional enhanced scopes.

It is important to know, that

* `__stack` is stored in COPPER after the calls (may be empty)
* `__stack` is used for next call
* `__stackPosition` is not stored.
It is `0` each time the `main` is called

=== The byte code of the original Workflow

Our first Java byte code assembly belongs to the original Workflow.

[source%nowrap,java,linenums]
----
include::{bytecodeDir}/OneSavepoint.txt[]
----

<1> Irrelevant constructor `init`
<2> Relevant `main`method
<3> The `savepoint`

If you often use Java code and no byte code, you also can understand it without all details.
You can see the original `LINENUMBER` lines, connected to label L1, L2, ...
The `LDC` lines holds string, you also find in Java the code.

=== The byte code of the instrumented Workflow

As we have seen the Java byte code assembly belonging to the original Workflow, we can now look into the instrumented.
It is harder to understand, than the decompiled Java code.

[source%nowrap,java,linenums]
----
include::{instrumentedDir}/OneSavepoint.txt[]
----

<1> Goto the end of the method
<2> Start of original `main`
<3> The `savepoint`
<4> Creating the `StackEntry`
<5> Continue label after `safepoint` incl. adjusting `__stack` and `__stackPosition`
<6> Behind the original end of method
<7> Goto start of original `main`
<8> Reading the `StackEntry`
<9> Goto continue label after `safepoint`

We see, that creating the `StackEntry` is in the method, behind the `savepoint`.
Reading the `StackEntry` ist behind the original end of method.

[[SavepointsAndSubWorkflows]]
== Example with Savepoints and Subworkflows

Here is a more complex Workflow with several `savepoint`s.

=== The original Workflow

It also has `subWorkflow`, called in `main`.
And there is a `subWorkflow2`, called in `subWorkflow`.

[source%nowrap,java,linenums]
----
include::{workflowDir}/SavepointsAndSubWorkflows.java[]
----

<1> Call of `subWorkflow` with 2 parameters
<2> Call of `subWorkflows` with 1 parameter (array of long)

=== The decompiled instrumented Workflow

This is the instrumented Workflow with incorrect Java code, generated by a decompiler.
Nevertheless, it helps to understand more of the COPPER internals.

We see the handling of SubWorkflows (Interruptable methods).
The parameters are also stored in a `StackEntry`.

[source%nowrap,java,linenums]
----
include::{decompiledDir}/SavepointsAndSubWorkflows.java[]
----

<1> Variable used as parameter for the `subWorkflow`
<2> Variable used as parameter for the `subWorkflow`
<3> Create `StackEntry` with `jumpNo=3` incl. `stack` with parameters
<4> Prepare variables used as parameter before 1st call of `subWorkflow`
<5> Increment `__stackPosition` before calling `subWorkflow`
<6> Condition for `jumpNo=3` to call `subWorkflow`
<7> Prepare variables used as parameter before other calls of `subWorkflow`
<8> Increment `__stackPosition` before calling `subWorkflow`
<9> Call of `subWorkflow`
<10> Instrumented handling for `Interrupt`

`subWorkflow2` is added for analyzing deeper call structures.

The concept for the implementation of continuations in COPPER should be cleared now.

[[Implementation]]
== Implementation

In this chapter we step deeper into the implementation.
It contains several links into the source code repository, where you might start more analysis.
We start with more information about `Interrupt`.

=== Interrupt

We saw, that throwing an `Interrupt` is the was to end a continuation before it will be resumed later.
To avoid unexpected side effects in try, catch and finally handling must be instrumented.
In the last example it was visible in the decompiled Workflow.

The major responsible class for this aspect is the https://github.com/copper-engine/copper-engine/blob/master/projects/copper-coreengine/src/main/java/org/copperengine/core/instrument/TryCatchBlockHandler.java[`TryCatchBlockHandler`]

`Interrupt` throwable must not be handled or thrown.
Catching it, leads to an exception.
Creating it, leads to a warning.

=== Workflow

The class
https://github.com/copper-engine/copper-engine/blob/master/projects/copper-coreengine/src/main/java/org/copperengine/core/Workflow.java[`Workflow`]
holds the above-mentioned `\__stack` and `__stackPosition` and

[source,java]
----
  public void __beforeProcess() {
        __stackPosition = 0;
    }
----

Analysing the `transient` members might be interesting

=== Engine

COPPER offers two engines, which control and store the continuation.

* https://github.com/copper-engine/copper-engine/blob/master/projects/copper-coreengine/src/main/java/org/copperengine/core/persistent/PersistentScottyEngine.java#L232[Persistent engine stores `Workflow` in a DB (see dbStorage.insert)]
* https://github.com/copper-engine/copper-engine/blob/master/projects/copper-coreengine/src/main/java/org/copperengine/core/tranzient/TransientScottyEngine.java#L182[Transient engine stores `Workflow` in memory (see workflowMap.put)]

=== WorkflowRepository

The
https://github.com/copper-engine/copper-engine/blob/master/projects/copper-coreengine/src/main/java/org/copperengine/core/wfrepo/AbstractWorkflowRepository.java#L211[AbstractWorkflowRepository]
controls the instrumentation using the major classes:

* https://github.com/copper-engine/copper-engine/blob/master/projects/copper-coreengine/src/main/java/org/copperengine/core/instrument/TryCatchBlockHandler.java[`TryCatchBlockHandler`]
we already discussed above
* https://github.com/copper-engine/copper-engine/blob/master/projects/copper-coreengine/src/main/java/org/copperengine/core/instrument/ScottyClassAdapter.java[`ScottyClassAdapter`]
connecting [`ScottyMethodAdapter`] and [`BuildStackInfoAdapter`]
* https://github.com/copper-engine/copper-engine/blob/master/projects/copper-coreengine/src/main/java/org/copperengine/core/instrument/ScottyMethodAdapter.java[`ScottyMethodAdapter`]
implementing major methods `visitMethodInsn` and `visitEnd`
* https://github.com/copper-engine/copper-engine/blob/master/projects/copper-coreengine/src/main/java/org/copperengine/core/instrument/BuildStackInfoAdapter.java[`BuildStackInfoAdapter`]
keeping track of type information in `StackEntry`


==== Last Workflow

The last Workflow we analyze has one `savepoint` and a try, catch, finally.

[source%nowrap,java,linenums]
----
include::{workflowDir}/OneSavepointWithTryCatchFinally.java[]
----

==== The byte code of the instrumented Workflow with trace

To analyze the responsibilities for instrumentation, we look at the instrumented Workflow with trace.

[source%nowrap,java,linenums]
----
include::{traceDir}/OneSavepointWithTryCatchFinally.txt[]
----

<1> Start `ScottyMethodAdapter.visitMethodInsn`
<2> End `ScottyMethodAdapter.visitMethodInsn`
<3> Start `TryCatchBlockHandler.instrument`
<4> End `TryCatchBlockHandler.instrument`
<5> Start `TryCatchBlockHandler.instrument`
<6> End `TryCatchBlockHandler.instrument`
<7> Start `ScottyMethodAdapter.visitEnd`
<8> Inside `ScottyMethodAdapter.visitEnd`
<9> End `ScottyMethodAdapter.visitEnd`

==== The byte code of the instrumented Workflow with trace

You might have noticed the two sequences for `finally`.
These already existed in the not instrumented byte code.

[source%nowrap,java,linenums]
----
include::{bytecodeDir}/OneSavepointWithTryCatchFinally.txt[]
----

<1> 1st finally sequence
<2> 2nd finally sequence

== AnalyseTest

One test, that shows some internal is the
https://github.com/copper-engine/copper-engine/blob/master/projects/copper-regtest/src/test/java/org/copperengine/regtest/test/analyse/AnalyseTest.java[`AnalyseTest`].
